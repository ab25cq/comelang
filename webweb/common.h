#ifndef __COMMON_H__
#define __COMMON_H__
#include <neo-c.h>
#include <neo-c-net.h>
struct sInfo;

interface sNode
{
    unsigned int id();
    bool compile(sInfo* info);
}
struct ZVALUE;

struct ZVALUE
{
    enum { kIntValue, kStrValue, kBoolValue, kNullValue, kFileValue, kListValue, kMapValue } kind;

    int intValue;
    wstring strValue;
    bool boolValue;
    FILE* fileValue;
    list<ZVALUE*%>*% listValue;
    map<ZVALUE*%, ZVALUE*%>*% mapValue;
};
struct sInfo
{
    char* p;
    string command;
    buffer*% codes;
    list<sNode*%>*% nodes;
    int* op;
    char* head;
    list<ZVALUE*%>*% stack;

    ZVALUE*% result_value;

    int stack_num;

    list<int>*% breaks;
    int loop_head;
};
typedef list<sNode*%>*% sNodeBlock;
enum { OP_INT_VALUE=1, OP_IADD, OP_ISUB, OP_IMUL, OP_IDIV, OP_IMOD, OP_IEQ , OP_INOTEQ, OP_IGT , OP_ILT , OP_IGTEQ , OP_ILTEQ , OP_IANDAND , OP_IOROR , OP_POP , OP_STR_VALUE , OP_TRUE_VALUE , OP_FALSE_VALUE , OP_STORE , OP_LOAD , OP_IF , OP_GOTO , OP_PRINT , OP_STDIN , OP_STDOUT , OP_STDERR , OP_REGEX_VALUE , OP_LIST_VALUE , OP_MAP_VALUE , OP_FUN OP_LOAD_ELEMENT , OP_STORE_ELEMENT };
struct sIntNode;
struct sAddNode;
struct sSubNode;
struct sMultNode;
struct sDivNode;
struct sModNode;
struct sEqNode;
struct sNotEqNode;
struct sGTEqNode;
struct sLTEqNode;
struct sGTNode;
struct sLTNode;
struct sAndAndNode;
struct sOrOrNode;
struct sStrNode;
struct sListNode;
struct sMapNode;
struct sStoreNode;
struct sLoadNode;
struct sLoadElementNode;
struct sStoreElementNode;
struct sIfNode;
struct sTrueNode;
struct sFalseNode;
struct sWhileNode;
struct sBreakNode;
struct sPrintNode;
struct sStdinNode;
struct sStdoutNode;
struct sStderrNode;
struct sFunNode;
extern int sNode*::get_hash_key(sNode* self);
extern bool sNode*::equals(sNode* self,sNode* right);
extern int gNodeID;
extern void skip_spaces(sInfo* info);
extern int ZVALUE*::get_hash_key(ZVALUE* self);
extern bool ZVALUE*::equals(ZVALUE* self,ZVALUE* right);
extern int ZVALUE*::compare(ZVALUE* self,ZVALUE* right);
extern bool ZVALUE*::operator_equals(ZVALUE* self,ZVALUE* right);
extern bool ZVALUE*::operator_not_equals(ZVALUE* self,ZVALUE* right);
extern string ZVALUE*::to_string(ZVALUE* self);
extern ZVALUE*% ZVALUE*::initialize(ZVALUE*% self,int kind,int int_value=0,wstring str_value=null,bool bool_value=false,FILE* file_value=null,list<ZVALUE*%>*% list_value=null,map<ZVALUE*%,ZVALUE*%>*% map_value=null);
extern sIntNode*% sIntNode*::initialize(sIntNode*% self,int value);
extern int sIntNode*::id(sIntNode* self);
extern bool sIntNode*::compile(sIntNode* self,sInfo* info);
extern sNode*% exp_node(sInfo* info) version 1;
extern sNode*% expression(sInfo* info) version 1;
extern bool parse(sInfo* info) version 1;
extern void arrange_stack(sInfo* info);
extern bool vm(sInfo* info) version 1;
extern sAddNode*% sAddNode*::initialize(sAddNode*% self,sNode*% left,sNode*% right);
extern int sAddNode*::id(sAddNode* self);
extern bool sAddNode*::compile(sAddNode* self,sInfo* info);
extern sSubNode*% sSubNode*::initialize(sSubNode*% self,sNode*% left,sNode*% right);
extern int sSubNode*::id(sSubNode* self);
extern bool sSubNode*::compile(sSubNode* self,sInfo* info);
extern sNode*% op_mult_node(sInfo* info) version 1;
extern sNode*% op_add_node(sInfo* info);
extern sNode*% expression(sInfo* info) version 2;
extern bool vm(sInfo* info) version 2;
extern sMultNode*% sMultNode*::initialize(sMultNode*% self,sNode*% left,sNode*% right);
extern int sMultNode*::id(sMultNode* self);
extern bool sMultNode*::compile(sMultNode* self,sInfo* info);
extern sDivNode*% sDivNode*::initialize(sDivNode*% self,sNode*% left,sNode*% right);
extern int sDivNode*::id(sDivNode* self);
extern bool sDivNode*::compile(sDivNode* self,sInfo* info);
extern sModNode*% sModNode*::initialize(sModNode*% self,sNode*% left,sNode*% right);
extern int sModNode*::id(sModNode* self);
extern bool sModNode*::compile(sModNode* self,sInfo* info);
extern sEqNode*% sEqNode*::initialize(sEqNode*% self,sNode*% left,sNode*% right);
extern int sEqNode*::id(sEqNode* self);
extern bool sEqNode*::compile(sEqNode* self,sInfo* info);
extern sNotEqNode*% sNotEqNode*::initialize(sNotEqNode*% self,sNode*% left,sNode*% right);
extern int sNotEqNode*::id(sNotEqNode* self);
extern bool sNotEqNode*::compile(sNotEqNode* self,sInfo* info);
extern sGTEqNode*% sGTEqNode*::initialize(sGTEqNode*% self,sNode*% left,sNode*% right);
extern int sGTEqNode*::id(sGTEqNode* self);
extern bool sGTEqNode*::compile(sGTEqNode* self,sInfo* info);
extern sLTEqNode*% sLTEqNode*::initialize(sLTEqNode*% self,sNode*% left,sNode*% right);
extern int sLTEqNode*::id(sLTEqNode* self);
extern bool sLTEqNode*::compile(sLTEqNode* self,sInfo* info);
extern sGTNode*% sGTNode*::initialize(sGTNode*% self,sNode*% left,sNode*% right);
extern int sGTNode*::id(sGTNode* self);
extern bool sGTNode*::compile(sGTNode* self,sInfo* info);
extern sLTNode*% sLTNode*::initialize(sLTNode*% self,sNode*% left,sNode*% right);
extern int sLTNode*::id(sLTNode* self);
extern bool sLTNode*::compile(sLTNode* self,sInfo* info);
extern sNode*% op_mult_node(sInfo* info) version 2;
extern sAndAndNode*% sAndAndNode*::initialize(sAndAndNode*% self,sNode*% left,sNode*% right);
extern int sAndAndNode*::id(sAndAndNode* self);
extern bool sAndAndNode*::compile(sAndAndNode* self,sInfo* info);
extern sOrOrNode*% sOrOrNode*::initialize(sOrOrNode*% self,sNode*% left,sNode*% right);
extern int sOrOrNode*::id(sOrOrNode* self);
extern bool sOrOrNode*::compile(sOrOrNode* self,sInfo* info);
extern sNode*% op_eq_node(sInfo* info);
extern sNode*% op_andand_node(sInfo* info);
extern sNode*% expression(sInfo* info) version 3;
extern bool vm(sInfo* info) version 3;
extern void append_str_to_codes(sInfo* info,wchar_t* str);
extern wstring get_str_from_codes(sInfo* info);
extern sStrNode*% sStrNode*::initialize(sStrNode*% self,wstring value);
extern int sStrNode*::id(sStrNode* self);
extern bool sStrNode*::compile(sStrNode* self,sInfo* info);
extern bool vm(sInfo* info) version 4;
extern sNode*% exp_node(sInfo* info) version 2;
extern sListNode*% sListNode*::initialize(sListNode*% self,list<sNode*%>*% value);
extern int sListNode*::id(sListNode* self);
extern bool sListNode*::compile(sListNode* self,sInfo* info);
extern sMapNode*% sMapNode*::initialize(sMapNode*% self,list<tuple2<sNode*%,sNode*%>*%>*% value);
extern int sMapNode*::id(sMapNode* self);
extern bool sMapNode*::compile(sMapNode* self,sInfo* info);
extern bool vm(sInfo* info) version 5;
extern sNode*% exp_node(sInfo* info) version 3;
extern bool vm(sInfo* info) version 6;
extern sNode*% exp_node(sInfo* info) version 4;
extern sStoreNode*% sStoreNode*::initialize(sStoreNode*% self,wstring var_name,sNode*% right);
extern bool sStoreNode*::compile(sStoreNode* self,sInfo* info);
extern int sStoreNode*::id(sStoreNode* self);
extern sLoadNode*% sLoadNode*::initialize(sLoadNode*% self,wstring var_name);
extern bool sLoadNode*::compile(sLoadNode* self,sInfo* info);
extern int sLoadNode*::id(sLoadNode* self);
extern sLoadElementNode*% sLoadElementNode*::initialize(sLoadElementNode*% self,string var_name,sNode*% index);
extern int sLoadElementNode*::id(sLoadElementNode* self);
extern bool sLoadElementNode*::compile(sLoadElementNode* self,sInfo* info);
extern sStoreElementNode*% sStoreElementNode*::initialize(sStoreElementNode*% self,string var_name,sNode*% index,sNode*% right);
extern int sStoreElementNode*::id(sStoreElementNode* self);
extern bool sStoreElementNode*::compile(sStoreElementNode* self,sInfo* info);
extern map<wstring,ZVALUE*%>*% gVars;
extern ZVALUE gNullValue;
extern void initialize_modules() version 2;
extern void finalize_modules() version 2;
extern bool vm(sInfo* info) version 7;
extern sNode*% exp_node(sInfo* info) version 5;
extern void append_var(wstring name,ZVALUE* value);
extern bool compile_block(sNodeBlock block,sInfo* info);
extern sIfNode*% sIfNode*::initialize(sIfNode*% self,sNode*% if_exp,sNodeBlock if_block,list<sNode*%>*% elif_exps,list<sNodeBlock>*% elif_blocks,sNodeBlock else_block);
extern int sIfNode*::id(sIfNode* self);
extern bool sIfNode*::compile(sIfNode* self,sInfo* info);
extern sTrueNode*% sTrueNode*::initialize(sTrueNode*% self);
extern int sTrueNode*::id(sTrueNode* self);
extern bool sTrueNode*::compile(sTrueNode* self,sInfo* info);
extern sFalseNode*% sFalseNode*::initialize(sFalseNode*% self);
extern int sFalseNode*::id(sFalseNode* self);
extern bool sFalseNode*::compile(sFalseNode* self,sInfo* info);
extern bool vm(sInfo* info) version 8;
extern sNodeBlock parse_block(sInfo* info);
extern bool is_word(char* str,sInfo* info);
extern sNode*% exp_node(sInfo* info) version 6;
extern sWhileNode*% sWhileNode*::initialize(sWhileNode*% self,sNode*% while_exp,sNodeBlock while_block);
extern int sWhileNode*::id(sWhileNode* self);
extern bool sWhileNode*::compile(sWhileNode* self,sInfo* info);
extern sBreakNode*% sBreakNode*::initialize(sBreakNode*% self);
extern int sBreakNode*::id(sBreakNode* self);
extern bool sBreakNode*::compile(sBreakNode* self,sInfo* info);
extern sNode*% exp_node(sInfo* info) version 7;
extern sPrintNode*% sPrintNode*::initialize(sPrintNode*% self,sNode*% print_exp);
extern int sPrintNode*::id(sPrintNode* self);
extern bool sPrintNode*::compile(sPrintNode* self,sInfo* info);
extern sStdinNode*% sStdinNode*::initialize(sStdinNode*% self);
extern int sStdinNode*::id(sStdinNode* self);
extern bool sStdinNode*::compile(sStdinNode* self,sInfo* info);
extern sStdoutNode*% sStdoutNode*::initialize(sStdoutNode*% self);
extern int sStdoutNode*::id(sStdoutNode* self);
extern bool sStdoutNode*::compile(sStdoutNode* self,sInfo* info);
extern sStderrNode*% sStderrNode*::initialize(sStderrNode*% self);
extern int sStderrNode*::id(sStderrNode* self);
extern bool sStderrNode*::compile(sStderrNode* self,sInfo* info);
extern bool vm(sInfo* info) version 9;
extern sNode*% exp_node(sInfo* info) version 8;
extern sFunNode*% sFunNode*::initialize(sFunNode*% self,string name,sNode*% obj,list<sNode*%>*% params,sNodeBlock block);
extern int sFunNode*::id(sFunNode* self);
extern bool sFunNode*::compile(sFunNode* self,sInfo* info);
extern sNode*% exp_node(sInfo* info) version 9;
extern tuple2<ZVALUE*%,bool>*% str_method(string fun_name,ZVALUE* obj,list<ZVALUE*%>* params,buffer* codes,sInfo* info) version 1;
extern bool vm(sInfo* info) version 10;
extern tuple2<ZVALUE*%,bool>*% str_method(string fun_name,ZVALUE* obj,list<ZVALUE*%>* params,buffer* codes,sInfo* info) version 2;
extern tuple2<ZVALUE*%,bool>*% str_method(string fun_name,ZVALUE* obj,list<ZVALUE*%>* params,buffer* codes,sInfo* info) version 3;
extern void handle_sigint(int sig);
extern tuple2<string,int>*% eval_zed(string command);
extern string parse_html(string file_contents);
extern tuple2<string,int>*% xpopen(char** argv,string input);
extern void run_post_cgi(SSL* it,string file_path,string header,string contents);
extern void run_post_cgi_http(int it,string file_path,string header,string contents);
extern void run_get_cgi(SSL* it,string cgi_path,string header,string contents,string query_string);
extern void run_get_cgi_http(int it,string cgi_path,string header,string contents,string query_string);
extern int main(int argc,char** argv);

#endif
